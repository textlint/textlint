{"version":3,"sources":["../../src/core/source-location.js"],"names":["assert","require","ObjectAssign","SourceLocation","source","reportedMessage","node","ruleError","ruleId","errorPrefix","padding","_backwardCompatibleIndexValue","line","undefined","column","index","Error","adjustedLoc","_adjustLoc","adjustedFix","_adjustFix","_paddingIndex","nodeRange","range","loc","start","startNodeIndex","paddingIndex","position","indexToPosition","addedLine","addedColumn","paddingMessage","fix","isAbsolute","text"],"mappings":"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","file":"source-location.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst assert = require(\"assert\");\nconst ObjectAssign = require(\"object-assign\");\nimport {throwIfTesting} from \"../util/throw-log\";\nexport default class SourceLocation {\n    /**\n     *\n     * @param {SourceCode} source\n     */\n    constructor(source) {\n        this.source = source;\n    }\n\n    /**\n     * adjust node's location with error's padding location.\n     * @param {ReportMessage} reportedMessage\n     * @returns {{line: number, column: number, fix?: FixCommand}}\n     */\n    adjust(reportedMessage) {\n        const {node, ruleError, ruleId} = reportedMessage;\n        const errorPrefix = `[${ruleId}]` || \"\";\n        const padding = ruleError;\n        /*\n         FIXME: It is old and un-document way\n         new RuleError(\"message\", index);\n         */\n        let _backwardCompatibleIndexValue;\n        if (typeof padding === \"number\") {\n            _backwardCompatibleIndexValue = padding;\n            throwIfTesting(`${errorPrefix} This is un-document way:\nreport(node, new RuleError(\"message\", index);\n\nPlease use { index }: \n\nreport(node, new RuleError(\"message\", {\n    index: paddingLineColumn\n});\n`);\n        }\n        // when running from textlint-tester, assert\n        if (padding.line === undefined && padding.column !== undefined) {\n            // FIXME: Backward compatible <= textlint.5.5\n            throwIfTesting(`${errorPrefix} Have to use a sets with \"line\" and \"column\".\nSee FAQ: https://github.com/textlint/textlint/blob/master/docs/faq/line-column-or-index.md            \n\nreport(node, new RuleError(\"message\", {\n    line: paddingLineNumber,\n    column: paddingLineColumn\n});\n\nOR use \"index\" property insteadof only \"column\".\n\nreport(node, new RuleError(\"message\", {\n    index: paddingLineColumn\n});\n`);\n        }\n\n        // Not use {column, line} with {index}\n        if ((padding.line !== undefined || padding.column !== undefined) && padding.index !== undefined) {\n            // Introduced textlint 5.6\n            // https://github.com/textlint/textlint/releases/tag/5.6.0\n            // Always throw Error\n            throw new Error(`${errorPrefix} Have to use {line, column} or index.\n=> use either one of the two\n\nreport(node, new RuleError(\"message\", {\n    line: paddingLineNumber,\n    column: paddingLineColumn\n});\n\nOR use \"index\" property\n\nreport(node, new RuleError(\"message\", {\n    index: paddingIndexValue\n});\n`);\n        }\n\n        const adjustedLoc = this._adjustLoc(node, padding, _backwardCompatibleIndexValue);\n        const adjustedFix = this._adjustFix(node, padding);\n        /*\n         {\n         line,\n         column\n         fix?\n         }\n         */\n        return ObjectAssign({}, adjustedLoc, adjustedFix);\n    }\n\n    _adjustLoc(node, padding, _paddingIndex) {\n        const nodeRange = node.range;\n        const line = node.loc.start.line;\n        const column = node.loc.start.column;\n\n        // when use {index}\n        if (padding.index !== undefined || _paddingIndex !== undefined) {\n            const startNodeIndex = nodeRange[0];\n            const paddingIndex = _paddingIndex || padding.index;\n            const position = this.source.indexToPosition(startNodeIndex + paddingIndex);\n            return {\n                column: position.column,\n                line: position.line\n            };\n        }\n        // when use {line, column}\n        if (padding.line !== undefined && padding.column !== undefined) {\n            if (padding.line > 0) {\n                const addedLine = line + padding.line;\n                // when report with padding {line, column}, message.column should be 0 + padding.column.\n                // In other word, padding line > 0 and message.column start with 0.\n                if (padding.column > 0) {\n                    return {\n                        line: addedLine,\n                        column: padding.column\n                    };\n                } else {\n                    return {\n                        line: addedLine,\n                        column\n                    };\n                }\n            }\n        }\n        // when use { line } only\n        if (padding.line !== undefined && padding.line > 0) {\n            const addedLine = line + padding.line;\n            return {\n                line: addedLine,\n                column\n            };\n        }\n        // when use { column } only\n        // FIXME: backward compatible @ un-document\n        // Remove next version 6?\n        /*\n         new RuleError({\n         column: index\n         });\n         */\n        if (padding.column !== undefined && padding.column > 0) {\n            const addedColumn = column + padding.column;\n            return {\n                line,\n                column: addedColumn\n            };\n        }\n\n        return {\n            column,\n            line\n        };\n    }\n\n    /**\n     * Adjust `fix` command range\n     * if `fix.isAbsolute` is not absolute position, adjust the position from the `node`.\n     * @param {TxtNode} node\n     * @param {TextLintMessage} paddingMessage\n     * @returns {FixCommand|Object}\n     * @private\n     */\n    _adjustFix(node, paddingMessage) {\n        const nodeRange = node.range;\n        // if not found `fix`, return empty object\n        if (paddingMessage.fix === undefined) {\n            return {};\n        }\n        assert(typeof paddingMessage.fix === \"object\", \"fix should be FixCommand object\");\n        // if absolute position return self\n        if (paddingMessage.fix.isAbsolute) {\n            return {\n                // remove other property that is not related `fix`\n                // the return object will be merged by `Object.assign`\n                fix: {\n                    range: paddingMessage.fix.range,\n                    text: paddingMessage.fix.text\n                }\n            };\n        }\n        // if relative position return adjusted position\n        return {\n            // fix(command) is relative from node's range\n            fix: {\n                range: [nodeRange[0] + paddingMessage.fix.range[0], nodeRange[0] + paddingMessage.fix.range[1]],\n                text: paddingMessage.fix.text\n            }\n        };\n    }\n}\n"]}