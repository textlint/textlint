{"version":3,"sources":["../../src/core/source-code.js"],"names":["assert","require","StructuredSource","validate","ast","loc","Error","range","SourceCode","text","ext","filePath","hasBOM","charCodeAt","slice","_structuredSource","node","beforeCount","afterCount","currentText","start","Math","max","end","locationToRange","rangeToLocation","pos","positionToIndex","index","indexToPosition"],"mappings":";;;;;;;;;;AAEA;AAAA;AAAA;;;;;;AAFA,IAAMA,SAASC,QAAQ,QAAR,CAAf;AACA,IAAMC,mBAAmBD,QAAQ,mBAAR,CAAzB;;AAEA;;;;;;;AAOA,SAASE,QAAT,CAAkBC,GAAlB,EAAuB;AACnB,QAAI,CAACA,IAAIC,GAAT,EAAc;AACV,cAAM,IAAIC,KAAJ,CAAU,sCAAV,CAAN;AACH;;AAED,QAAI,CAACF,IAAIG,KAAT,EAAgB;AACZ,cAAM,IAAID,KAAJ,CAAU,kCAAV,CAAN;AACH;AACJ;;AAED;;;;IAGqBE,U;AACjB,8BAA6C;AAAA,6BAAhCC,IAAgC;AAAA,YAAhCA,IAAgC,6BAAzB,EAAyB;AAAA,YAArBL,GAAqB,QAArBA,GAAqB;AAAA,YAAhBM,GAAgB,QAAhBA,GAAgB;AAAA,YAAXC,QAAW,QAAXA,QAAW;;AAAA;;AACzCR,iBAASC,GAAT;AACAJ,eAAOU,OAAOC,QAAd,EAAwB,8CAAxB;AACA,aAAKC,MAAL,GAAcH,KAAKI,UAAL,CAAgB,CAAhB,MAAuB,MAArC;AACA,aAAKJ,IAAL,GAAa,KAAKG,MAAL,GAAcH,KAAKK,KAAL,CAAW,CAAX,CAAd,GAA8BL,IAA3C;AACA;;;AAGA,aAAKM,iBAAL,GAAyB,IAAIb,gBAAJ,CAAqB,KAAKO,IAA1B,CAAzB;AACA,aAAKL,GAAL,GAAWA,GAAX;AACA,aAAKO,QAAL,GAAgBA,QAAhB;AACA;AACA,aAAKD,GAAL,GAAWA,GAAX;AACH;;AAED;;;;;;;oCAGY;AACR;AACH;;AAED;;;;;;;sCAIc;AACV,mBAAO,KAAKC,QAAZ;AACH;;AAED;;;;;;;;;;kCAOUK,I,EAAMC,W,EAAaC,U,EAAY;AACrC,gBAAMC,cAAc,KAAKV,IAAzB;AACA,gBAAIU,eAAe,IAAnB,EAAyB;AACrB,uBAAO,IAAP;AACH;AACD,gBAAIH,IAAJ,EAAU;AACN,oBAAMI,QAAQC,KAAKC,GAAL,CAASN,KAAKT,KAAL,CAAW,CAAX,KAAiBU,eAAe,CAAhC,CAAT,EAA6C,CAA7C,CAAd;AACA,oBAAMM,MAAMP,KAAKT,KAAL,CAAW,CAAX,KAAiBW,cAAc,CAA/B,CAAZ;AACA,uBAAOC,YAAYL,KAAZ,CAAkBM,KAAlB,EAAyBG,GAAzB,CAAP;AACH,aAJD,MAIO;AACH,uBAAOJ,WAAP;AACH;AACJ;;AAED;AACA;;;;;;;wCAIgBd,G,EAAK;AACjB,mBAAO,KAAKU,iBAAL,CAAuBS,eAAvB,CAAuCnB,GAAvC,CAAP;AACH;;AAED;;;;;;;wCAIgBE,K,EAAO;AACnB,mBAAO,KAAKQ,iBAAL,CAAuBU,eAAvB,CAAuClB,KAAvC,CAAP;AACH;;AAED;;;;;;;wCAIgBmB,G,EAAK;AACjB,mBAAO,KAAKX,iBAAL,CAAuBY,eAAvB,CAAuCD,GAAvC,CAAP;AACH;;AAED;;;;;;;wCAIgBE,K,EAAO;AACnB,mBAAO,KAAKb,iBAAL,CAAuBc,eAAvB,CAAuCD,KAAvC,CAAP;AACH;;;;;;kBAnFgBpB,U","file":"source-code.js","sourcesContent":["const assert = require(\"assert\");\nconst StructuredSource = require(\"structured-source\");\nimport TextLintNodeType from \"../shared/type/TextLintNodeType\";\n/**\n * Validates that the given AST has the required information.\n * @param {TxtAST.TxtNode} [ast] The Program node of the AST to check.\n * @throws {Error} If the AST doesn't contain the correct information.\n * @returns {void}\n * @private\n */\nfunction validate(ast) {\n    if (!ast.loc) {\n        throw new Error(\"AST is missing location information.\");\n    }\n\n    if (!ast.range) {\n        throw new Error(\"AST is missing range information\");\n    }\n}\n\n/**\n * This class represent of source code.\n */\nexport default class SourceCode {\n    constructor({text = \"\", ast, ext, filePath}) {\n        validate(ast);\n        assert(ext || filePath, \"should be set either of fileExt or filePath.\");\n        this.hasBOM = text.charCodeAt(0) === 0xFEFF;\n        this.text = (this.hasBOM ? text.slice(1) : text);\n        /**\n         * @type StructuredSource\n         */\n        this._structuredSource = new StructuredSource(this.text);\n        this.ast = ast;\n        this.filePath = filePath;\n        // fileType .md .txt ...\n        this.ext = ext;\n    }\n\n    /**\n     * @returns {TextLintNodeType}\n     */\n    getSyntax() {\n        return TextLintNodeType;\n    }\n\n    /**\n     * get filePath\n     * @returns {string|undefined}\n     */\n    getFilePath() {\n        return this.filePath;\n    }\n\n    /**\n     * Gets the source code for the given node.\n     * @param {TxtNode=} node The AST node to get the text for.\n     * @param {int=} beforeCount The number of characters before the node to retrieve.\n     * @param {int=} afterCount The number of characters after the node to retrieve.\n     * @returns {string|null} The text representing the AST node.\n     */\n    getSource(node, beforeCount, afterCount) {\n        const currentText = this.text;\n        if (currentText == null) {\n            return null;\n        }\n        if (node) {\n            const start = Math.max(node.range[0] - (beforeCount || 0), 0);\n            const end = node.range[1] + (afterCount || 0);\n            return currentText.slice(start, end);\n        } else {\n            return currentText;\n        }\n    }\n\n    // StructuredSource wrapper\n    /**\n     * @param {SourceLocation} loc - location indicator.\n     * @return {[ number, number ]} range.\n     */\n    locationToRange(loc) {\n        return this._structuredSource.locationToRange(loc);\n    }\n\n    /**\n     * @param {[ number, number ]} range - pair of indice.\n     * @return {SourceLocation} location.\n     */\n    rangeToLocation(range) {\n        return this._structuredSource.rangeToLocation(range);\n    }\n\n    /**\n     * @param {Position} pos - position indicator.\n     * @return {number} index.\n     */\n    positionToIndex(pos) {\n        return this._structuredSource.positionToIndex(pos);\n    }\n\n    /**\n     * @param {number} index - index to the source code.\n     * @return {Position} position.\n     */\n    indexToPosition(index) {\n        return this._structuredSource.indexToPosition(index);\n    }\n}\n"]}