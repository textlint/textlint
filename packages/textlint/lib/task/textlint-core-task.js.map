{"version":3,"sources":["../../src/task/textlint-core-task.js"],"names":["EventEmitter","require","TraverseController","Controller","PromiseEventEmitter","traverseController","debug","assert","RuleTypeEmitter","setMaxListeners","TextLintCoreTask","start","message","complete","error","ruleTypeEmitter","reportFunction","reportedMessage","ruleId","range","optional","type","ignore","ignoringRuleId","emit","events","sourceCode","sourceLocation","severity","ruleError","adjust","line","column","fix","index","positionToIndex","lint","data","promiseQueue","listenerCount","bind","traverse","ast","enter","node","parent","Object","defineProperty","value","promise","push","leave","Promise","all","then","catch","ruleCreator","ruleContext","ruleConfig","id","ruleObject","tryToGetRuleObject","keys","forEach","on","nodeType","enabled","time"],"mappings":"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","file":"textlint-core-task.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst EventEmitter = require(\"events\");\nconst TraverseController = require(\"txt-ast-traverse\").Controller;\nconst PromiseEventEmitter = require(\"carrack\");\nconst traverseController = new TraverseController();\nconst debug = require(\"debug\")(\"textlint:core-task\");\nconst assert = require(\"assert\");\nimport RuleError from \"../core/rule-error\";\nimport SourceLocation from \"../core/source-location\";\nimport timing from \"./../util/timing\";\nimport MessageType from \"../shared/type/MessageType\";\n\n// Promised EventEmitter\nclass RuleTypeEmitter extends PromiseEventEmitter {\n    constructor() {\n        super();\n        this.setMaxListeners(0);\n    }\n}\n\n/**\n * CoreTask receive AST and prepare, traverse AST, emit nodeType event!\n * You can observe task and receive \"message\" event that is TextLintMessage.\n */\nexport default class TextLintCoreTask extends EventEmitter {\n    static get events() {\n        return {\n            // receive start event\n            start: \"start\",\n            // receive message from each rules\n            message: \"message\",\n            // receive complete event\n            complete: \"complete\",\n            // receive error event\n            error: \"error\"\n        };\n    }\n\n    constructor() {\n        super();\n        this.ruleTypeEmitter = new RuleTypeEmitter();\n    }\n\n    createIgnoreReporter() {\n        /**\n         * Message of ignoring\n         * @typedef {Object} ReportIgnoreMessage\n         * @property {string} ruleId\n         * @property {number[]} range\n         * @property {string} ignoringRuleId to ignore ruleId\n         * \"*\" is special case, it match all ruleId(work as wildcard).\n         */\n        /**\n         * create ReportIgnoreMessage and emit it.\n         * @param {ReportIgnoreMessage} reportedMessage\n         */\n        const reportFunction = (reportedMessage) => {\n            const {ruleId, range, optional} = reportedMessage;\n            assert(typeof range[0] !== \"undefined\" && typeof range[1] !== \"undefined\" && range[0] >= 0 && range[1] >= 0,\n                \"ignoreRange should have actual range: \" + range);\n            const message = {\n                type: MessageType.ignore,\n                ruleId: ruleId,\n                range: range,\n                // ignoring target ruleId - default: filter all messages\n                ignoringRuleId: optional.ruleId || \"*\"\n            };\n            this.emit(TextLintCoreTask.events.message, message);\n        };\n        return reportFunction;\n    }\n\n    createReporter(sourceCode) {\n        const sourceLocation = new SourceLocation(sourceCode);\n\n        /**\n         * @typedef {Object} ReportMessage\n         * @property {string} ruleId\n         * @property {TxtNode} node\n         * @property {number} severity\n         * @property {RuleError} ruleError error is a RuleError instance or any data\n         */\n        /**\n         * push new RuleError to results\n         * @param {ReportMessage} reportedMessage\n         */\n        const reportFunction = (reportedMessage) => {\n            const {ruleId, severity, ruleError} = reportedMessage;\n            debug(\"%s pushReport %s\", ruleId, ruleError);\n            const {line, column, fix} = sourceLocation.adjust(reportedMessage);\n            const index = sourceCode.positionToIndex({line, column});\n            // add TextLintMessage\n            const message = {\n                type: MessageType.lint,\n                ruleId: ruleId,\n                message: ruleError.message,\n                index,\n                // See https://github.com/textlint/textlint/blob/master/typing/textlint.d.ts\n                line: line,        // start with 1(1-based line number)\n                column: column + 1,// start with 1(1-based column number)\n                severity: severity // it's for compatible ESLint formatter\n            };\n            if (fix) {\n                message.fix = fix;\n            }\n            if (!(ruleError instanceof RuleError)) {\n                // `error` is a any data.\n                const data = ruleError;\n                message.data = data;\n            }\n            this.emit(TextLintCoreTask.events.message, message);\n        };\n        return reportFunction;\n    }\n\n    /**\n     * start process and emitting events.\n     * You can listen message by `task.on(\"message\", message => {})`\n     * @param {SourceCode} sourceCode\n     */\n    startTraverser(sourceCode) {\n        const promiseQueue = [];\n        const listenerCount = (typeof this.ruleTypeEmitter.listenerCount !== \"undefined\")\n            ? this.ruleTypeEmitter.listenerCount.bind(this.ruleTypeEmitter) // Node 4.x >=\n            : EventEmitter.listenerCount.bind(EventEmitter, this.ruleTypeEmitter);// Node 0.12\n        this.emit(TextLintCoreTask.events.start);\n        const ruleTypeEmitter = this.ruleTypeEmitter;\n        traverseController.traverse(sourceCode.ast, {\n            enter(node, parent) {\n                const type = node.type;\n                Object.defineProperty(node, \"parent\", {value: parent});\n                if (listenerCount(type) > 0) {\n                    const promise = ruleTypeEmitter.emit(type, node);\n                    promiseQueue.push(promise);\n                }\n            },\n            leave(node) {\n                const type = `${node.type}:exit`;\n                if (listenerCount(type) > 0) {\n                    const promise = ruleTypeEmitter.emit(type, node);\n                    promiseQueue.push(promise);\n                }\n            }\n        });\n        Promise.all(promiseQueue).then(() => {\n            this.emit(TextLintCoreTask.events.complete);\n        }).catch(error => {\n            this.emit(TextLintCoreTask.events.error, error);\n        });\n    }\n\n    /**\n     * try to get rule object\n     * @param {Function} ruleCreator\n     * @param {RuleContext|FilterRuleContext} ruleContext\n     * @param {Object|boolean} ruleConfig\n     * @returns {Object}\n     * @throws\n     */\n    tryToGetRuleObject(ruleCreator, ruleContext, ruleConfig) {\n        try {\n            return ruleCreator(ruleContext, ruleConfig);\n        } catch (error) {\n            error.message = `Error while loading rule '${ruleContext.id}': ${error.message}`;\n            throw error;\n        }\n    }\n\n    /**\n     * add all the node types as listeners of the rule\n     * @param {Function} ruleCreator\n     * @param {RuleContext|FilterRuleContext} ruleContext\n     * @param {Object|boolean} ruleConfig\n     * @returns {Object}\n     */\n    tryToAddListenRule(ruleCreator, ruleContext, ruleConfig) {\n        const ruleObject = this.tryToGetRuleObject(ruleCreator, ruleContext, ruleConfig);\n        Object.keys(ruleObject).forEach(nodeType => {\n            this.ruleTypeEmitter.on(nodeType, timing.enabled\n                ? timing.time(ruleContext.id, ruleObject[nodeType])\n                : ruleObject[nodeType]);\n        });\n    }\n}\n"]}