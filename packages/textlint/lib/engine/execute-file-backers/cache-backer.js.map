{"version":3,"sources":["../../../src/engine/execute-file-backers/cache-backer.js"],"names":["fileEntryCache","require","debug","CacheBacker","config","isEnabled","cache","fileCache","create","cacheLocation","hashOfConfig","hash","filePath","descriptor","getFileDescriptor","meta","isNotChanged","changed","result","messages","length","removeEntry","destroy","reconcile"],"mappings":"AAAA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAFA,IAAMA,iBAAiBC,QAAQ,kBAAR,CAAvB;AACA,IAAMC,QAAQD,QAAQ,OAAR,EAAiB,aAAjB,CAAd;;IAEqBE,W;;;AACjB;;;AAGA,yBAAYC,MAAZ,EAAoB;AAAA;;AAEhB;;;AAFgB;;AAKhB,cAAKC,SAAL,GAAiBD,OAAOE,KAAxB;AACA,cAAKC,SAAL,GAAiBP,eAAeQ,MAAf,CAAsBJ,OAAOK,aAA7B,CAAjB;AACA;;;AAGA,cAAKC,YAAL,GAAoBN,OAAOO,IAA3B;AAVgB;AAWnB;;AAED;;;;;;;;4CAI0B;AAAA,gBAAXC,QAAW,QAAXA,QAAW;;AACtB,gBAAI,CAAC,KAAKP,SAAV,EAAqB;AACjB,uBAAO,IAAP;AACH;AACD,gBAAMQ,aAAa,KAAKN,SAAL,CAAeO,iBAAf,CAAiCF,QAAjC,CAAnB;AACA,gBAAMG,OAAOF,WAAWE,IAAX,IAAmB,EAAhC;AACA;AACA,gBAAMC,eAAeH,WAAWI,OAAX,IAAsBF,KAAKL,YAAL,KAAsB,KAAKA,YAAtE;AACAR,2DAA6CU,QAA7C;AACA,mBAAOI,YAAP;AACH;;AAED;;;;;;0CAGqB;AAAA,gBAATE,MAAS,SAATA,MAAS;;AACjB,gBAAI,CAAC,KAAKb,SAAV,EAAqB;AACjB;AACH;AACD,gBAAMO,WAAWM,OAAON,QAAxB;AACA,gBAAMC,aAAa,KAAKN,SAAL,CAAeO,iBAAf,CAAiCF,QAAjC,CAAnB;AACA,gBAAMG,OAAOF,WAAWE,IAAX,IAAmB,EAAhC;AACA;;;;AAIA,gBAAIG,OAAOC,QAAP,CAAgBC,MAAhB,GAAyB,CAA7B,EAAgC;AAC5BlB,2DAAyCU,QAAzC;AACA;AACA,qBAAKL,SAAL,CAAec,WAAf,CAA2BT,QAA3B;AACH,aAJD,MAIO;AACH;AACAG,qBAAKL,YAAL,GAAoB,KAAKA,YAAzB;AACH;AACJ;;AAED;;;;;;uCAGe;AACX,iBAAKH,SAAL,CAAee,OAAf;AACH;;;mCAEU;AACP;AACA,iBAAKf,SAAL,CAAegB,SAAf;AACH;;;;;;kBAnEgBpB,W","file":"cache-backer.js","sourcesContent":["// MIT Â© 2016 azu\n\"use strict\";\nconst fileEntryCache = require(\"file-entry-cache\");\nconst debug = require(\"debug\")(\"CacheBacker\");\nimport AbstractBacker from \"./abstruct-backer\";\nexport default class CacheBacker extends AbstractBacker {\n    /**\n     * @param {Config} config\n     */\n    constructor(config) {\n        super();\n        /**\n         * @type {boolean}\n         */\n        this.isEnabled = config.cache;\n        this.fileCache = fileEntryCache.create(config.cacheLocation);\n        /**\n         * @type {string}\n         */\n        this.hashOfConfig = config.hash;\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {boolean}\n     */\n    shouldExecute({filePath}) {\n        if (!this.isEnabled) {\n            return true;\n        }\n        const descriptor = this.fileCache.getFileDescriptor(filePath);\n        const meta = descriptor.meta || {};\n        // if the config is changed or file is changed, should execute return true\n        const isNotChanged = descriptor.changed || meta.hashOfConfig !== this.hashOfConfig;\n        debug(`Skipping file since hasn't changed: ${filePath}`);\n        return isNotChanged;\n    }\n\n    /**\n     * @param {TextLintResult} result\n     */\n    didExecute({result}) {\n        if (!this.isEnabled) {\n            return;\n        }\n        const filePath = result.filePath;\n        const descriptor = this.fileCache.getFileDescriptor(filePath);\n        const meta = descriptor.meta || {};\n        /*\n         * if a file contains messages we don't want to store the file in the cache\n         * so we can guarantee that next execution will also operate on this file\n         */\n        if (result.messages.length > 0) {\n            debug(`File has problems, skipping it: ${filePath}`);\n            // remove the entry from the cache\n            this.fileCache.removeEntry(filePath);\n        } else {\n            // cache `config.hash`\n            meta.hashOfConfig = this.hashOfConfig;\n        }\n    }\n\n    /**\n     * destroy all cache\n     */\n    destroyCache() {\n        this.fileCache.destroy();\n    }\n\n    afterAll() {\n        // persist cache\n        this.fileCache.reconcile();\n    }\n}\n"]}